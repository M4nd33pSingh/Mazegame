package de.mazegame.algo;

import de.mazegame.model.Maze;
import de.mazegame.model.Node;

import java.util.concurrent.ThreadLocalRandom; // ...a random number between 0 to 3
import java.util.Stack;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashMap;

public class Generator {
    private final Maze maze;
    private final int startX, startY;
    private final Stack<Node> stack = new Stack<>();
    /**
     * Needed for the game itself, because it will save the valid directions,
     * which the user is allowed to move to and it also saves how the the maze was generated by
     * reading the value-list of a key like a stack.
     *
     * It is also needed to calculate the solution Path from a players' current position to end.
     */
    private final Map<Node, ArrayList<Node>> spanning3 = new HashMap<>();

    public Generator(Maze maze) {
        this.maze = maze;
        // chooses a random starting 'node' in the range of node count minus 1 of the 1st row for startX
        // and row count minus 1 for startY, because the last node in each row and the last row were
        // added only to show a right and bottom border for the user to see.
        this.startX = ThreadLocalRandom.current().nextInt(0, maze.getColumnCount() - 1);
        this.startY = ThreadLocalRandom.current().nextInt(0,    maze.getRowCount() - 1);
        generateMaze();
    }

    public int getStartX() {
        return startX;
    }

    public int getStartY() {
        return startY;
    }

    /**
     * Generate a real existing, memory allocating copy of the spanning3 and not a shallow copy or not just the references.
     * This copy gets 'consumed' in PathFinder.setSolutionPath() because while searching the solutionPath the copyOfSpanning3 gets "destroyed".<p>
     *
     * TODO: 'real existing' copy of the Node's object instance as in all attributes is not really necessary, because only the coordinates
     * defined by the attributes Node.x, Node.y are sufficient to accomplish the same for how this copy of spanning3 is used for finding a
     * solution-pathway from Player's current position coordinates (x,y) up to Player's target coordinate in the PathFinder or for the game.logic
     * of validation of user's movement direction coordinates (Player).																		<br>
     * Therefore this 'real existing' copy allocates more memory than really needed, but on the other hand
     * @return a reference to this copyOfSpanning3 really REAL copyOfSpanning3, and now fake as in references or shallow copy.
     */
    public Map<Node, ArrayList<Node>> getSpanning3() {
        Map<Node, ArrayList<Node>> copyOfSpanning3 = new HashMap<>();
        for (Node node:spanning3.keySet()) {
            copyOfSpanning3.put(node, new ArrayList<Node>());
            for (int i=0; i<spanning3.get(node).size(); i++)
                copyOfSpanning3.get(node).add(spanning3.get(node).get(i));
        }
        return copyOfSpanning3;
    }

    /**
     *
     * https://en.wikipedia.org/wiki/Maze_generation_algorithm#:~:text=in%20the%20area.-,Iterative%20implementation,-%5Bedit%5D
     * <p>
     * 1. Choose the initial cell*, mark it as visited and push it to the stack <br>
     * 2. While the stack is not empty										    <br>
     * 2.1. Pop a cell from the stack and make it a current cell*			    <br>
     * 2.2. If the current cell* has any neighbors which have not been visited  <br>
     * 2.2.1.  Push the current cell* to the stack 			  			        <br>
     * 2.2.2.  Choose one of the unvisited neighbors			  			    <br>
     * 2.2.3.  Remove the wall between the current cell* and the chosen cell**  <br>
     * 2.2.4.  Mark the chosen cell** as visited and push it to the stack		<p>
     * (* currentNode, ** nextNode)
     */
    private void generateMaze() {
        int x, y, direction, neighborIndex;
        final int right=0, down=1, left=2, up=3;
        Node nextNode, currentNode = maze.getNode(startX, startY); // 1;
        currentNode.setVisited(true);                  // 1
        stack.push(currentNode);                       // 1

        spanning3.put(currentNode, new ArrayList<>());

        while(!stack.empty()) {                        // 2
            currentNode = stack.pop();                 // 2.1

            if (currentNode.hasNeighbors()) {          // 2.2
                stack.push(currentNode);               // 2.2.1

                neighborIndex = ThreadLocalRandom.current().nextInt(0, currentNode.getNeighbors().size());// 2.2.2
                // check the method setNeighbors in the model.Node class for how the neighbor's array in the neighbors-ArrayList is built
                x = currentNode.getNeighbors().get(neighborIndex)[0];                                      // 2.2.2
                y = currentNode.getNeighbors().get(neighborIndex)[1];                                      // 2.2.2
                direction = currentNode.getNeighbors().get(neighborIndex)[2];                              // 2.2.2
                currentNode.getNeighbors().remove(neighborIndex);                                          // 2.2.2

                nextNode = maze.getNode(x, y);                                                             // 2.2.2

                if (!nextNode.isVisited()) {           // 2.2
                    // "deletes" either the north or the west Wall in either current node or next node.
                    switch (direction) {                // 2.2.3
                        case right -> nextNode.setWest(false);   // wall belongs to next node: east from current node
                        case down -> nextNode.setNorth(false);   // wall belongs to next node: south from current node
                        case left -> currentNode.setWest(false); // wall belongs to current node next node: west from current node
                        case up -> currentNode.setNorth(false);  // wall belongs to current node next node: north from current node
                    }
                    // this needed for validating whether a user is...
                    spanning3.get(currentNode).add(nextNode);     // ...allowed to move to that node, which represents users' chosen direction
                    if (spanning3.containsKey(nextNode))      // the solution path uses also the spanning3 by choosing...
                        spanning3.get(nextNode).add(currentNode); // a random direction at that specific node, to find solution,
                    else {                                // without checking if that direction is valid, because the spanning3...
                        spanning3.put(nextNode, new ArrayList<>()); // ...will store only valid connections...
                        spanning3.get(nextNode).add(currentNode); // ...between 2 nodes, if it is not obscured by a wall (which got removed above)
                    }
                    nextNode.setVisited(true);         // 2.2.4
                    stack.push(nextNode);              // 2.2.4
                }
            }
        }
    }
}
